#!/usr/bin/env python
from datetime import datetime
from hashlib import sha1
from re import compile
from sys import argv
from zipfile import ZipFile

from pdfminer.high_level import extract_pages
from pdfminer.layout import LTTextBoxHorizontal, LTPage

def format_head(description, serial_number, date_str, time_str):
    day, month, year = date_str
    month = dict({
        'enero': 1,
        'febrero': 2,
        'marzo': 3,
        'abril': 4,
        'mayo': 5,
        'junio': 6,
        'julio': 7,
        'agosto': 8,
        'septiembre': 9,
        'octubre': 10,
        'noviembre': 11,
        'diciembre': 12,
    })[month]
    hour, minute = time_str.split(':')
    date = datetime(int(year), month, int(day), int(hour), int(minute))
    relevant_date_w3c = date.strftime('%Y-%m-%dT%H:%M') + ':00+01:00'
    return f'''{{
    "organizationName": "",
    "description": "{description}",
    "serialNumber": "{serial_number}",
    "relevantDate": "{relevant_date_w3c}",
    "backgroundColor": "rgb(0, 31, 106)",
    "formatVersion": 1,
    "boardingPass": {{
        "primaryFields": ['''


def format_field(key, value, label):
    return \
        f'''
            {{
                "value": "{value}",
                "key": "{key}",
                "label": "{label}"
            }}'''


def format_footer():
    return '''
        ],
        "transitType": "PKTransitTypeGeneric"
    },
    "teamIdentifier": ""
}'''


def format_manifest(sha1sum):
    return f'''{{
    "pass.json": "{sha1sum}"
}}'''


def create_pkpass(name, pass_, manifest):
    try:
        pass_file = ZipFile(name, 'x')
    except FileExistsError:
        exit("File " + name + " already exists.")

    pass_file.writestr('pass.json', pass_)
    pass_file.writestr('manifest.json', manifest)

def parse_pdf_page(page_layout):
    ticket = {}
    date_pattern = compile(r'^(\d+) (\w+) (\d{4})\n$')
    time_pattern = compile(r'^(\d\d:\d\d)\n$')
    text_pattern = compile(r'^(\w+)\n$')
    number_pattern = compile(r'^(\d+)\n$')
    service_pattern = compile(r'^Paradas: .*\nLÃ­nea: (.*)\n$')
    localizer_pattern = compile(r'^Localizador\n(.*)\n$')

    current = None
    it = iter(page_layout)
    element = next(it)

    while (
        not isinstance(element, LTTextBoxHorizontal)
        or element.get_text() != "Tu billete\n"
    ):
        element = next(it)
    element = next(it)

    current = date_pattern.fullmatch(element.get_text())
    while current is None:
        element = next(it)
        while not isinstance(element, LTTextBoxHorizontal):
            element = next(it)
        current = date_pattern.fullmatch(element.get_text())
    ticket['start_date'] = current.groups()
    element = next(it)

    current = time_pattern.fullmatch(element.get_text())
    while current is None:
        element = next(it)
        while not isinstance(element, LTTextBoxHorizontal):
            element = next(it)
        current = time_pattern.fullmatch(element.get_text())
    ticket['start_time'] = current.group(1)
    element = next(it)

    current = text_pattern.fullmatch(element.get_text())
    while current is None:
        element = next(it)
        while not isinstance(element, LTTextBoxHorizontal):
            element = next(it)
        current = text_pattern.fullmatch(element.get_text())
    ticket['start_city'] = current.group(1)
    element = next(it)

    current = date_pattern.fullmatch(element.get_text())
    while current is None:
        element = next(it)
        while not isinstance(element, LTTextBoxHorizontal):
            element = next(it)
        current = date_pattern.fullmatch(element.get_text())
    ticket['end_date'] = current.groups()
    element = next(it)

    current = time_pattern.fullmatch(element.get_text())
    while current is None:
        element = next(it)
        while not isinstance(element, LTTextBoxHorizontal):
            element = next(it)
        current = time_pattern.fullmatch(element.get_text())
    ticket['end_time'] = current.group(1)
    element = next(it)

    current = text_pattern.fullmatch(element.get_text())
    while current is None:
        element = next(it)
        while not isinstance(element, LTTextBoxHorizontal):
            element = next(it)
        current = text_pattern.fullmatch(element.get_text())
    ticket['end_city'] = current.group(1)
    element = next(it)

    ticket['start_address'] = element.get_text().rstrip("\n")
    element = next(it)
    ticket['end_address'] = element.get_text().rstrip("\n")
    element = next(it)

    current_number = None
    current_service = None
    current_localizer = None
    try:
        while True:
            current_number = number_pattern.fullmatch(element.get_text())
            current_service = service_pattern.fullmatch(element.get_text())
            current_localizer = localizer_pattern.fullmatch(element.get_text())
            if current_number is not None:
                if 'bus' not in ticket:
                    ticket['bus'] = current_number.group(1)
                else:
                    ticket['seat'] = current_number.group(1)
            if current_service is not None:
                ticket['service'] = current_service.group(1).strip()
            if current_localizer is not None:
                ticket['localizer'] = current_localizer.group(1)
            element = next(it)
            while not isinstance(element, LTTextBoxHorizontal):
                element = next(it)
    except StopIteration:
        pass

    return ticket


def main():
    if len(argv) < 2:
        exit("Specify input PDF.")

    try:
        page_layout = extract_pages(argv[1])
    except FileNotFoundError:
        exit("Error reading input PDF.")

    # PDFs for one way tickets have 2 pages, ticket summary and receipt
    # PDFs with return tickets have 4 pages, with receipts in the last two pages
    ticket_page = None
    return_ticket_page = None
    it = iter(page_layout)
    ticket_page = next(it)
    return_ticket_page = next(it)
    try:
        extra_page = next(it)
    except StopIteration:
        return_ticket_page = None

    tickets = [
        parse_pdf_page(ticket_page),
        (
            parse_pdf_page(return_ticket_page)
            if return_ticket_page is not None
            else None
        )
    ]

    all_fields = []
    for ticket in tickets:
        for field in [
            'service',
            'localizer',
            'start_city',
            'end_city',
            'start_date',
            'start_time'
        ]:
            if field not in ticket:
                raise RuntimeError(f"Field {field} missing in ticket: {ticket}")
        all_fields.append([
            format_field('service', ticket['service'], 'Linea: '),
            format_field('localizer', ticket['localizer'], 'Localizador: '),
            format_field('origin', ticket['start_city'], 'Origen: '),
            format_field('destination', ticket['end_city'], 'Destino: '),
            format_field('bus', ticket['bus'] if 'bus' in ticket else '-', 'Bus: '),
            format_field('seat', ticket['seat'] if 'seat' in ticket else '-', 'Asiento: '),
        ])

    ticket = (
        format_head(tickets[0]['service'], tickets[0]['localizer'] + "_t", tickets[0]['start_date'], tickets[0]['start_time']) +
        ",".join(all_fields[0]) +
        format_footer()
    )

    ticket_manifest = format_manifest(
        str(sha1(ticket.encode('utf-8')).hexdigest())
    )

    ticket_name = 'ticket_' + tickets[0]['localizer'] + '.pkpass'
    print("Writing " + ticket_name + " ...")
    create_pkpass(ticket_name, ticket, ticket_manifest)


    if len(tickets) == 2:

        return_ticket = (
            format_head(tickets[1]['service'], tickets[1]['localizer'] + "_r", tickets[1]['start_date'], tickets[1]['start_time']) +
            ",".join(all_fields[1]) +
            format_footer()
        )

        return_ticket_manifest = format_manifest(
            str(sha1(return_ticket.encode('utf-8')).hexdigest())
        )

        return_ticket_name = 'ticket_return_' + tickets[1]['localizer'] + '.pkpass'
        print("Writing " + return_ticket_name + " ...")
        create_pkpass(return_ticket_name, return_ticket, return_ticket_manifest)

    print("Done.")


if __name__ == '__main__':
    main()
